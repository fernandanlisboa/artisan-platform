from app.domain.repositories.user_repository_interface import IUserRepository
from app.domain.repositories.artisan_repository_interface import IArtisanRepository
from app.domain.models.user import UserEntity as User # AGORA IMPORTA A ENTIDADE PURA
from app.domain.models.artisan import ArtisanEntity as Artisan
from app.presentation.dtos.user_dtos import RegisterArtisanRequest
class UserRegistrationService:
    #TODO add buyer repository
    def __init__(self, user_repository: IUserRepository, artisan_repository: IArtisanRepository):
        self.user_repository = user_repository
        self.artisan_repository = artisan_repository
        
    def register_artisan(self, request_data: RegisterArtisanRequest) -> User: # Retorna Entidade Pura
        """
        Registers a new artisan user in the system.
        Performs validations and persists both User and Artisan models.
        """
        
        user_entity = User(
            user_id=None, # ID will be generated by the entity
            email=request_data.email, 
            password=request_data.password, # Pass plain password to the entity
            status='active' 
        )
        
        # 5. Persist the User entity via UserRepository (converts to DBModel internally)
        saved_user_entity = self.user_repository.save(user_entity)
        
        # 6. Create the Artisan domain entity
        artisan_entity = Artisan(
            artisan_id=saved_user_entity.user_id, # Artisan's ID is the same as the User's ID
            store_name=request_data.store_name,
            phone=request_data.phone,
            bio=request_data.bio
            )
        
        # 7. Persist Artisan entity via ArtisanRepository (converts to DBModel internally)
        self.artisan_repository.save(artisan_entity) 

        # 8. Send confirmation email (uncomment when service is implemented)
        # self.email_service.send_confirmation_email(saved_user_entity.email) 

        return saved_user_entity