import pytest
from unittest.mock import Mock
import uuid
from app.application.services.user_registration_service import UserRegistrationService
from app.domain.repositories.user_repository_interface import IUserRepository
from app.domain.repositories.artisan_repository_interface import IArtisanRepository
from app.domain.models.user import UserEntity as User 
from app.domain.models.artisan import ArtisanEntity as Artisan

class TestArtisanRegistration:
  
  def test_register_artisan_successfully(self):
    mock_user_repository = Mock(spec=IUserRepository)
    mock_artisan_repository = Mock(spec=IArtisanRepository)
    # Mock the save method to return a UserEntity with the expected attributes
    # TODO find by email to check if email already exists
    # mock_user_repository.find_by_email.return_value = None
    
    service = UserRegistrationService(user_repository=mock_user_repository, artisan_repository=mock_artisan_repository) 
    
    expected_user_id = str(uuid.uuid4()) # Gere um ID para o mock
    saved_user_entity = User(user_id=expected_user_id, email="test@artisan.com", password="SecurePassword123", status='active')
    mock_user_repository.save.return_value = saved_user_entity 

    mock_artisan_repository.save.side_effect = lambda artisan_obj: artisan_obj 

    # O ArtisanRepository.save() precisa retornar uma MockArtisanEntity com os dados certos
    mock_artisan_repository.save.return_value = MockArtisanEntity(
        artisan_id=expected_user_id, # O artisan_id deve ser o mesmo user_id
        store_name="My Test Shop",
        phone="1234567890",
        bio="Handmade goods",
        status='active'
    )
    # --- FIM DA CORREÇÃO ---
    email = "test@artisan.com"
    password = "SecurePassword123"
    store_name = "My Test Shop"
    phone = "1234567890"
    bio = "Handmade goods"
    
    registered_user = service.register_artisan(email, password, store_name, phone, bio)
    print(f"Registered User: {registered_user}")
    
    # Capture the argument passed to user_repository.save() for more detailed assertion
    saved_user_arg = mock_user_repository.save.call_args[0][0]
    assert isinstance(saved_user_arg, User) # Should be a pure User entity
    assert saved_user_arg.password == password # Assert on the plain password passed to pure User entity
    assert saved_user_arg.password == saved_user_entity.password # Assert on the hash generated by pure User entity

    mock_artisan_repository.save.assert_called_once()
    # Capture the argument passed to artisan_repository.save()
    saved_artisan_arg = mock_artisan_repository.save.call_args[0][0]
    assert isinstance(saved_artisan_arg, Artisan) # Should be a pure Artisan entity
    assert saved_artisan_arg.artisan_id == registered_user.user_id
    assert saved_artisan_arg.store_name == store_name
    assert saved_artisan_arg.phone == phone
    assert saved_artisan_arg.bio == bio
    
    
  #TODO registro com email ja existente
  #TODO registro com senha fraca
  #TODO registro com dados inválidos (store_name, phone, bio)